<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `flag` mod in crate `signal_hook`."><meta name="keywords" content="rust, rustlang, rust-lang, flag"><title>signal_hook::flag - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script src="../../storage.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../favicon.svg">
<link rel="alternate icon" type="image/png" href="../../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../signal_hook/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a><p class='location'>Module flag</p><div class="sidebar-elems"><div class="block items"><ul><li><a href="#functions">Functions</a></li></ul></div><p class='location'><a href='../index.html'>signal_hook</a></p><script>window.sidebarCurrent = {name: 'flag', ty: 'mod', relpath: '../'};</script><script defer src="../sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><span class="help-button">?</span>
                <a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../../src/signal_hook/flag.rs.html#1-214' title='goto source code'>[src]</a></span><span class='in-band'>Module <a href='../index.html'>signal_hook</a>::<wbr><a class="mod" href=''>flag</a></span></h1><div class='docblock'><p>Module for actions setting flags.</p>
<p>This contains helper functions to set flags whenever a signal happens. The flags are atomic
bools or numbers and the library manipulates them with the <code>SeqCst</code> ordering, in case someone
cares about relative order to some <em>other</em> atomic variables. If you don't care about the
relative order, you are free to use <code>Ordering::Relaxed</code> when reading and resetting the flags.</p>
<h1 id="when-to-use" class="section-header"><a href="#when-to-use">When to use</a></h1>
<p>The flags in this module allow for polling if a signal arrived since the previous poll. The do
not allow blocking until something arrives.</p>
<p>Therefore, the natural way to use them is in applications that have some kind of iterative work
with both some upper and lower time limit on one iteration. If one iteration could block for
arbitrary time, the handling of the signal would be postponed for a long time. If the iteration
didn't block at all, the checking for the signal would turn into a busy-loop.</p>
<p>If what you need is blocking until a signal comes, you might find better tools in the
<a href="../pipe/"><code>pipe</code></a> and <a href="../iterator/"><code>iterator</code></a> modules.</p>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<p>Doing something until terminated. This also knows by which signal it was terminated. In case
multiple termination signals arrive before it is handled, it recognizes the last one.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">signal_hook</span>;

<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">io</span>::<span class="ident">Error</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">sync</span>::<span class="ident">Arc</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">sync</span>::<span class="ident">atomic</span>::{<span class="ident">AtomicUsize</span>, <span class="ident">Ordering</span>};

<span class="kw">use</span> <span class="ident">signal_hook</span>::<span class="ident">flag</span> <span class="kw">as</span> <span class="ident">signal_flag</span>;

<span class="kw">fn</span> <span class="ident">main</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Error</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">term</span> <span class="op">=</span> <span class="ident">Arc</span>::<span class="ident">new</span>(<span class="ident">AtomicUsize</span>::<span class="ident">new</span>(<span class="number">0</span>));
    <span class="kw">const</span> <span class="ident">SIGTERM</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="ident">signal_hook</span>::<span class="ident">SIGTERM</span> <span class="kw">as</span> <span class="ident">usize</span>;
    <span class="kw">const</span> <span class="ident">SIGINT</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="ident">signal_hook</span>::<span class="ident">SIGINT</span> <span class="kw">as</span> <span class="ident">usize</span>;
    <span class="kw">const</span> <span class="ident">SIGQUIT</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="ident">signal_hook</span>::<span class="ident">SIGQUIT</span> <span class="kw">as</span> <span class="ident">usize</span>;
    <span class="ident">signal_flag</span>::<span class="ident">register_usize</span>(<span class="ident">signal_hook</span>::<span class="ident">SIGTERM</span>, <span class="ident">Arc</span>::<span class="ident">clone</span>(<span class="kw-2">&amp;</span><span class="ident">term</span>), <span class="ident">SIGTERM</span>)<span class="question-mark">?</span>;
    <span class="ident">signal_flag</span>::<span class="ident">register_usize</span>(<span class="ident">signal_hook</span>::<span class="ident">SIGINT</span>, <span class="ident">Arc</span>::<span class="ident">clone</span>(<span class="kw-2">&amp;</span><span class="ident">term</span>), <span class="ident">SIGINT</span>)<span class="question-mark">?</span>;
    <span class="ident">signal_flag</span>::<span class="ident">register_usize</span>(<span class="ident">signal_hook</span>::<span class="ident">SIGQUIT</span>, <span class="ident">Arc</span>::<span class="ident">clone</span>(<span class="kw-2">&amp;</span><span class="ident">term</span>), <span class="ident">SIGQUIT</span>)<span class="question-mark">?</span>;

    <span class="kw">loop</span> {
        <span class="kw">match</span> <span class="ident">term</span>.<span class="ident">load</span>(<span class="ident">Ordering</span>::<span class="ident">Relaxed</span>) {
            <span class="number">0</span> <span class="op">=</span><span class="op">&gt;</span> {
                <span class="comment">// Do some useful stuff here</span>
            }
            <span class="ident">SIGTERM</span> <span class="op">=</span><span class="op">&gt;</span> {
                <span class="macro">eprintln</span><span class="macro">!</span>(<span class="string">&quot;Terminating on the TERM signal&quot;</span>);
                <span class="kw">break</span>;
            }
            <span class="ident">SIGINT</span> <span class="op">=</span><span class="op">&gt;</span> {
                <span class="macro">eprintln</span><span class="macro">!</span>(<span class="string">&quot;Terminating on the INT signal&quot;</span>);
                <span class="kw">break</span>;
            }
            <span class="ident">SIGQUIT</span> <span class="op">=</span><span class="op">&gt;</span> {
                <span class="macro">eprintln</span><span class="macro">!</span>(<span class="string">&quot;Terminating on the QUIT signal&quot;</span>);
                <span class="kw">break</span>;
            }
            <span class="kw">_</span> <span class="op">=</span><span class="op">&gt;</span> <span class="macro">unreachable</span><span class="macro">!</span>(),
        }
    }

    <span class="prelude-val">Ok</span>(())
}</pre></div>
<p>Sending a signal to self and seeing it arrived (not of a practical usage on itself):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">libc</span>;
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">signal_hook</span>;

<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">io</span>::<span class="ident">Error</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">sync</span>::<span class="ident">Arc</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">sync</span>::<span class="ident">atomic</span>::{<span class="ident">AtomicBool</span>, <span class="ident">Ordering</span>};
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">thread</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">time</span>::<span class="ident">Duration</span>;

<span class="kw">fn</span> <span class="ident">main</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Error</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">got</span> <span class="op">=</span> <span class="ident">Arc</span>::<span class="ident">new</span>(<span class="ident">AtomicBool</span>::<span class="ident">new</span>(<span class="bool-val">false</span>));
    <span class="ident">signal_hook</span>::<span class="ident">flag</span>::<span class="ident">register</span>(<span class="ident">signal_hook</span>::<span class="ident">SIGUSR1</span>, <span class="ident">Arc</span>::<span class="ident">clone</span>(<span class="kw-2">&amp;</span><span class="ident">got</span>))<span class="question-mark">?</span>;
    <span class="kw">unsafe</span> {
        <span class="ident">libc</span>::<span class="ident">raise</span>(<span class="ident">signal_hook</span>::<span class="ident">SIGUSR1</span>);
    }
    <span class="comment">// A sleep here, because it could run the signal handler in another thread and we may not</span>
    <span class="comment">// see the flag right away. This is still a hack and not guaranteed to work, it is just an</span>
    <span class="comment">// example!</span>
    <span class="ident">thread</span>::<span class="ident">sleep</span>(<span class="ident">Duration</span>::<span class="ident">from_secs</span>(<span class="number">1</span>));
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">got</span>.<span class="ident">load</span>(<span class="ident">Ordering</span>::<span class="ident">Relaxed</span>));
    <span class="prelude-val">Ok</span>(())
}</pre></div>
<p>Reloading a configuration on <code>SIGHUP</code> (which is a common behaviour of many UNIX daemons,
together with reopening the log file).</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">signal_hook</span>;

<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">io</span>::<span class="ident">Error</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">sync</span>::<span class="ident">Arc</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">sync</span>::<span class="ident">atomic</span>::{<span class="ident">AtomicBool</span>, <span class="ident">Ordering</span>};

<span class="kw">use</span> <span class="ident">signal_hook</span>::<span class="ident">flag</span> <span class="kw">as</span> <span class="ident">signal_flag</span>;

<span class="kw">fn</span> <span class="ident">main</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Error</span><span class="op">&gt;</span> {
    <span class="comment">// We start with true, to load the configuration in the very first iteration too.</span>
    <span class="kw">let</span> <span class="ident">reload</span> <span class="op">=</span> <span class="ident">Arc</span>::<span class="ident">new</span>(<span class="ident">AtomicBool</span>::<span class="ident">new</span>(<span class="bool-val">true</span>));
    <span class="kw">let</span> <span class="ident">term</span> <span class="op">=</span> <span class="ident">Arc</span>::<span class="ident">new</span>(<span class="ident">AtomicBool</span>::<span class="ident">new</span>(<span class="bool-val">false</span>));
    <span class="ident">signal_flag</span>::<span class="ident">register</span>(<span class="ident">signal_hook</span>::<span class="ident">SIGHUP</span>, <span class="ident">Arc</span>::<span class="ident">clone</span>(<span class="kw-2">&amp;</span><span class="ident">reload</span>))<span class="question-mark">?</span>;
    <span class="ident">signal_flag</span>::<span class="ident">register</span>(<span class="ident">signal_hook</span>::<span class="ident">SIGINT</span>, <span class="ident">Arc</span>::<span class="ident">clone</span>(<span class="kw-2">&amp;</span><span class="ident">term</span>))<span class="question-mark">?</span>;
    <span class="ident">signal_flag</span>::<span class="ident">register</span>(<span class="ident">signal_hook</span>::<span class="ident">SIGTERM</span>, <span class="ident">Arc</span>::<span class="ident">clone</span>(<span class="kw-2">&amp;</span><span class="ident">term</span>))<span class="question-mark">?</span>;
    <span class="ident">signal_flag</span>::<span class="ident">register</span>(<span class="ident">signal_hook</span>::<span class="ident">SIGQUIT</span>, <span class="ident">Arc</span>::<span class="ident">clone</span>(<span class="kw-2">&amp;</span><span class="ident">term</span>))<span class="question-mark">?</span>;
    <span class="kw">while</span> <span class="op">!</span><span class="ident">term</span>.<span class="ident">load</span>(<span class="ident">Ordering</span>::<span class="ident">Relaxed</span>) {
        <span class="comment">// Using swap here, not load, to reset it back to false once it is reloaded.</span>
        <span class="kw">if</span> <span class="ident">reload</span>.<span class="ident">swap</span>(<span class="bool-val">false</span>, <span class="ident">Ordering</span>::<span class="ident">Relaxed</span>) {
            <span class="comment">// Reload the config here</span>
        }
        <span class="comment">// Serve one request</span>
    }
    <span class="prelude-val">Ok</span>(())
}</pre></div>
</div><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table><tr class='module-item'><td><a class="fn" href="fn.register.html" title='signal_hook::flag::register fn'>register</a></td><td class='docblock-short'><p>Registers an action to set the flag to <code>true</code> whenever the given signal arrives.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.register_usize.html" title='signal_hook::flag::register_usize fn'>register_usize</a></td><td class='docblock-short'><p>Registers an action to set the flag to the given value whenever the signal arrives.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../../";window.currentCrate = "signal_hook";</script><script src="../../main.js"></script><script defer src="../../search-index.js"></script></body></html>