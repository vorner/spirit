<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `AioCb` struct in crate `nix`."><meta name="keywords" content="rust, rustlang, rust-lang, AioCb"><title>nix::sys::aio::AioCb - Rust</title><link rel="stylesheet" type="text/css" href="../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../../ayu.css" disabled ><script src="../../../storage.js"></script><noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../../favicon.svg">
<link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../../../down-arrow.svg");}</style></head><body class="rustdoc struct"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../../nix/index.html'><div class='logo-container rust-logo'><img src='../../../rust-logo.png' alt='logo'></div></a><p class='location'>Struct AioCb</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#implementations">Methods</a><div class="sidebar-links"><a href="#method.aio_return">aio_return</a><a href="#method.boxed_mut_slice">boxed_mut_slice</a><a href="#method.boxed_slice">boxed_slice</a><a href="#method.buffer">buffer</a><a href="#method.cancel">cancel</a><a href="#method.error">error</a><a href="#method.fd">fd</a><a href="#method.from_boxed_mut_slice">from_boxed_mut_slice</a><a href="#method.from_boxed_slice">from_boxed_slice</a><a href="#method.from_fd">from_fd</a><a href="#method.from_mut_ptr">from_mut_ptr</a><a href="#method.from_mut_slice">from_mut_slice</a><a href="#method.from_ptr">from_ptr</a><a href="#method.from_slice">from_slice</a><a href="#method.fsync">fsync</a><a href="#method.lio_opcode">lio_opcode</a><a href="#method.nbytes">nbytes</a><a href="#method.offset">offset</a><a href="#method.priority">priority</a><a href="#method.read">read</a><a href="#method.set_sigev_notify">set_sigev_notify</a><a href="#method.sigevent">sigevent</a><a href="#method.write">write</a></div><a class="sidebar-title" href="#trait-implementations">Trait Implementations</a><div class="sidebar-links"><a href="#impl-Debug">Debug</a><a href="#impl-Drop">Drop</a></div><a class="sidebar-title" href="#synthetic-implementations">Auto Trait Implementations</a><div class="sidebar-links"><a href="#impl-RefUnwindSafe">!RefUnwindSafe</a><a href="#impl-Send">!Send</a><a href="#impl-Sync">!Sync</a><a href="#impl-Unpin">Unpin</a><a href="#impl-UnwindSafe">!UnwindSafe</a></div><a class="sidebar-title" href="#blanket-implementations">Blanket Implementations</a><div class="sidebar-links"><a href="#impl-Any">Any</a><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a><a href="#impl-From%3CT%3E">From&lt;T&gt;</a><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a></div></div><p class='location'><a href='../../index.html'>nix</a>::<wbr><a href='../index.html'>sys</a>::<wbr><a href='index.html'>aio</a></p><script>window.sidebarCurrent = {name: 'AioCb', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><span class="help-button">?</span>
                <a id="settings-menu" href="../../../settings.html"><img src="../../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../../../src/nix/sys/aio.rs.html#135-146' title='goto source code'>[src]</a></span><span class='in-band'>Struct <a href='../../index.html'>nix</a>::<wbr><a href='../index.html'>sys</a>::<wbr><a href='index.html'>aio</a>::<wbr><a class="struct" href=''>AioCb</a></span></h1><div class="docblock type-decl hidden-by-usual-hider"><pre class='rust struct'>pub struct AioCb&lt;'a&gt; { /* fields omitted */ }</pre></div><div class='docblock'><p>AIO Control Block.</p>
<p>The basic structure used by all aio functions.  Each <code>AioCb</code> represents one
I/O request.</p>
</div><h2 id='implementations' class='small-section-header'>Implementations<a href='#implementations' class='anchor'></a></h2><h3 id='impl' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="struct" href="../../../nix/sys/aio/struct.AioCb.html" title="struct nix::sys::aio::AioCb">AioCb</a>&lt;'a&gt;</code><a href='#impl' class='anchor'></a><a class='srclink' href='../../../src/nix/sys/aio.rs.html#148-897' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.buffer' class="method"><code>pub fn <a href='#method.buffer' class='fnname'>buffer</a>(&amp;mut self) -&gt; <a class="enum" href="../../../nix/sys/aio/enum.Buffer.html" title="enum nix::sys::aio::Buffer">Buffer</a>&lt;'a&gt;</code><a class='srclink' href='../../../src/nix/sys/aio.rs.html#153-158' title='goto source code'>[src]</a></h4><div class='docblock'><p>Remove the inner <code>Buffer</code> and return it</p>
<p>It is an error to call this method while the <code>AioCb</code> is still in
progress.</p>
</div><h4 id='method.boxed_slice' class="method"><code>pub fn <a href='#method.boxed_slice' class='fnname'>boxed_slice</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;dyn <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;&gt;</code><a class='srclink' href='../../../src/nix/sys/aio.rs.html#167-180' title='goto source code'>[src]</a></h4><div class='docblock'><p>Remove the inner boxed slice, if any, and return it.</p>
<p>The returned value will be the argument that was passed to
<code>from_boxed_slice</code> when this <code>AioCb</code> was created.</p>
<p>It is an error to call this method while the <code>AioCb</code> is still in
progress.</p>
</div><h4 id='method.boxed_mut_slice' class="method"><code>pub fn <a href='#method.boxed_mut_slice' class='fnname'>boxed_mut_slice</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;dyn <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;&gt;</code><a class='srclink' href='../../../src/nix/sys/aio.rs.html#189-202' title='goto source code'>[src]</a></h4><div class='docblock'><p>Remove the inner boxed mutable slice, if any, and return it.</p>
<p>The returned value will be the argument that was passed to
<code>from_boxed_mut_slice</code> when this <code>AioCb</code> was created.</p>
<p>It is an error to call this method while the <code>AioCb</code> is still in
progress.</p>
</div><h4 id='method.fd' class="method"><code>pub fn <a href='#method.fd' class='fnname'>fd</a>(&amp;self) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/sys/unix/ext/io/type.RawFd.html" title="type std::sys::unix::ext::io::RawFd">RawFd</a></code><a class='srclink' href='../../../src/nix/sys/aio.rs.html#205-207' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns the underlying file descriptor associated with the <code>AioCb</code></p>
</div><h4 id='method.from_fd' class="method"><code>pub fn <a href='#method.from_fd' class='fnname'>from_fd</a>(fd: <a class="type" href="https://doc.rust-lang.org/nightly/std/sys/unix/ext/io/type.RawFd.html" title="type std::sys::unix::ext::io::RawFd">RawFd</a>, prio: <a class="type" href="../../../libc/unix/type.c_int.html" title="type libc::unix::c_int">c_int</a>, sigev_notify: <a class="enum" href="../../../nix/sys/signal/enum.SigevNotify.html" title="enum nix::sys::signal::SigevNotify">SigevNotify</a>) -&gt; <a class="struct" href="../../../nix/sys/aio/struct.AioCb.html" title="struct nix::sys::aio::AioCb">AioCb</a>&lt;'a&gt;</code><a class='srclink' href='../../../src/nix/sys/aio.rs.html#245-258' title='goto source code'>[src]</a></h4><div class='docblock'><p>Constructs a new <code>AioCb</code> with no associated buffer.</p>
<p>The resulting <code>AioCb</code> structure is suitable for use with <code>AioCb::fsync</code>.</p>
<h1 id="parameters" class="section-header"><a href="#parameters">Parameters</a></h1>
<ul>
<li><code>fd</code>:           File descriptor.  Required for all aio functions.</li>
<li><code>prio</code>:         If POSIX Prioritized IO is supported, then the
operation will be prioritized at the process's
priority level minus <code>prio</code>.</li>
<li><code>sigev_notify</code>: Determines how you will be notified of event
completion.</li>
</ul>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<p>Create an <code>AioCb</code> from a raw file descriptor and use it for an
<a href="#method.fsync"><code>fsync</code></a> operation.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">f</span> <span class="op">=</span> <span class="ident">tempfile</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">aiocb</span> <span class="op">=</span> <span class="ident">AioCb</span>::<span class="ident">from_fd</span>( <span class="ident">f</span>.<span class="ident">as_raw_fd</span>(), <span class="number">0</span>, <span class="ident">SigevNone</span>);
<span class="ident">aiocb</span>.<span class="ident">fsync</span>(<span class="ident">AioFsyncMode</span>::<span class="ident">O_SYNC</span>).<span class="ident">expect</span>(<span class="string">&quot;aio_fsync failed early&quot;</span>);
<span class="kw">while</span> (<span class="ident">aiocb</span>.<span class="ident">error</span>() <span class="op">=</span><span class="op">=</span> <span class="prelude-val">Err</span>(<span class="ident">Error</span>::<span class="ident">from</span>(<span class="ident">Errno</span>::<span class="ident">EINPROGRESS</span>))) {
    <span class="ident">thread</span>::<span class="ident">sleep</span>(<span class="ident">time</span>::<span class="ident">Duration</span>::<span class="ident">from_millis</span>(<span class="number">10</span>));
}
<span class="ident">aiocb</span>.<span class="ident">aio_return</span>().<span class="ident">expect</span>(<span class="string">&quot;aio_fsync failed late&quot;</span>);</pre></div>
</div><h4 id='method.from_mut_slice' class="method"><code>pub fn <a href='#method.from_mut_slice' class='fnname'>from_mut_slice</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;fd: <a class="type" href="https://doc.rust-lang.org/nightly/std/sys/unix/ext/io/type.RawFd.html" title="type std::sys::unix::ext::io::RawFd">RawFd</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;offs: <a class="type" href="../../../libc/unix/linux_like/linux/gnu/b64/type.off_t.html" title="type libc::unix::linux_like::linux::gnu::b64::off_t">off_t</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;buf: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'a mut [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;prio: <a class="type" href="../../../libc/unix/type.c_int.html" title="type libc::unix::c_int">c_int</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;sigev_notify: <a class="enum" href="../../../nix/sys/signal/enum.SigevNotify.html" title="enum nix::sys::signal::SigevNotify">SigevNotify</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;opcode: <a class="enum" href="../../../nix/sys/aio/enum.LioOpcode.html" title="enum nix::sys::aio::LioOpcode">LioOpcode</a><br>) -&gt; <a class="struct" href="../../../nix/sys/aio/struct.AioCb.html" title="struct nix::sys::aio::AioCb">AioCb</a>&lt;'a&gt;</code><a class='srclink' href='../../../src/nix/sys/aio.rs.html#317-332' title='goto source code'>[src]</a></h4><div class='docblock'><p>Constructs a new <code>AioCb</code> from a mutable slice.</p>
<p>The resulting <code>AioCb</code> will be suitable for both read and write
operations, but only if the borrow checker can guarantee that the slice
will outlive the <code>AioCb</code>.  That will usually be the case if the <code>AioCb</code>
is stack-allocated.  If the borrow checker gives you trouble, try using
<a href="#method.from_boxed_mut_slice"><code>from_boxed_mut_slice</code></a> instead.</p>
<h1 id="parameters-1" class="section-header"><a href="#parameters-1">Parameters</a></h1>
<ul>
<li><code>fd</code>:           File descriptor.  Required for all aio functions.</li>
<li><code>offs</code>:         File offset</li>
<li><code>buf</code>:          A memory buffer</li>
<li><code>prio</code>:         If POSIX Prioritized IO is supported, then the
operation will be prioritized at the process's
priority level minus <code>prio</code></li>
<li><code>sigev_notify</code>: Determines how you will be notified of event
completion.</li>
<li><code>opcode</code>:       This field is only used for <code>lio_listio</code>.  It
determines which operation to use for this individual
aiocb</li>
</ul>
<h1 id="examples-1" class="section-header"><a href="#examples-1">Examples</a></h1>
<p>Create an <code>AioCb</code> from a mutable slice and read into it.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">const</span> <span class="ident">INITIAL</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>] <span class="op">=</span> <span class="string">b&quot;abcdef123456&quot;</span>;
<span class="kw">const</span> <span class="ident">LEN</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="number">4</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rbuf</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0</span>; <span class="ident">LEN</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">f</span> <span class="op">=</span> <span class="ident">tempfile</span>().<span class="ident">unwrap</span>();
<span class="ident">f</span>.<span class="ident">write_all</span>(<span class="ident">INITIAL</span>).<span class="ident">unwrap</span>();
{
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">aiocb</span> <span class="op">=</span> <span class="ident">AioCb</span>::<span class="ident">from_mut_slice</span>( <span class="ident">f</span>.<span class="ident">as_raw_fd</span>(),
        <span class="number">2</span>,   <span class="comment">//offset</span>
        <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">rbuf</span>,
        <span class="number">0</span>,   <span class="comment">//priority</span>
        <span class="ident">SigevNotify</span>::<span class="ident">SigevNone</span>,
        <span class="ident">LioOpcode</span>::<span class="ident">LIO_NOP</span>);
    <span class="ident">aiocb</span>.<span class="ident">read</span>().<span class="ident">unwrap</span>();
    <span class="kw">while</span> (<span class="ident">aiocb</span>.<span class="ident">error</span>() <span class="op">=</span><span class="op">=</span> <span class="prelude-val">Err</span>(<span class="ident">Error</span>::<span class="ident">from</span>(<span class="ident">Errno</span>::<span class="ident">EINPROGRESS</span>))) {
        <span class="ident">thread</span>::<span class="ident">sleep</span>(<span class="ident">time</span>::<span class="ident">Duration</span>::<span class="ident">from_millis</span>(<span class="number">10</span>));
    }
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">aiocb</span>.<span class="ident">aio_return</span>().<span class="ident">unwrap</span>() <span class="kw">as</span> <span class="ident">usize</span>, <span class="ident">LEN</span>);
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">rbuf</span>, <span class="string">b&quot;cdef&quot;</span>);</pre></div>
</div><h4 id='method.from_boxed_slice' class="method"><code>pub fn <a href='#method.from_boxed_slice' class='fnname'>from_boxed_slice</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;fd: <a class="type" href="https://doc.rust-lang.org/nightly/std/sys/unix/ext/io/type.RawFd.html" title="type std::sys::unix::ext::io::RawFd">RawFd</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;offs: <a class="type" href="../../../libc/unix/linux_like/linux/gnu/b64/type.off_t.html" title="type libc::unix::linux_like::linux::gnu::b64::off_t">off_t</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;buf: <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;dyn <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;, <br>&nbsp;&nbsp;&nbsp;&nbsp;prio: <a class="type" href="../../../libc/unix/type.c_int.html" title="type libc::unix::c_int">c_int</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;sigev_notify: <a class="enum" href="../../../nix/sys/signal/enum.SigevNotify.html" title="enum nix::sys::signal::SigevNotify">SigevNotify</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;opcode: <a class="enum" href="../../../nix/sys/aio/enum.LioOpcode.html" title="enum nix::sys::aio::LioOpcode">LioOpcode</a><br>) -&gt; <a class="struct" href="../../../nix/sys/aio/struct.AioCb.html" title="struct nix::sys::aio::AioCb">AioCb</a>&lt;'a&gt;</code><a class='srclink' href='../../../src/nix/sys/aio.rs.html#438-457' title='goto source code'>[src]</a></h4><div class='docblock'><p>The safest and most flexible way to create an <code>AioCb</code>.</p>
<p>Unlike <a href="#method.from_slice"><code>from_slice</code></a>, this method returns a structure suitable for
placement on the heap.  It may be used for write operations, but not
read operations.  Unlike <code>from_ptr</code>, this method will ensure that the
buffer doesn't <code>drop</code> while the kernel is still processing it.  Any
object that can be borrowed as a boxed slice will work.</p>
<h1 id="parameters-2" class="section-header"><a href="#parameters-2">Parameters</a></h1>
<ul>
<li><code>fd</code>:           File descriptor.  Required for all aio functions.</li>
<li><code>offs</code>:         File offset</li>
<li><code>buf</code>:          A boxed slice-like object</li>
<li><code>prio</code>:         If POSIX Prioritized IO is supported, then the
operation will be prioritized at the process's
priority level minus <code>prio</code></li>
<li><code>sigev_notify</code>: Determines how you will be notified of event
completion.</li>
<li><code>opcode</code>:       This field is only used for <code>lio_listio</code>.  It
determines which operation to use for this individual
aiocb</li>
</ul>
<h1 id="examples-2" class="section-header"><a href="#examples-2">Examples</a></h1>
<p>Create an <code>AioCb</code> from a Vector and use it for writing</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">wbuf</span> <span class="op">=</span> <span class="ident">Box</span>::<span class="ident">new</span>(<span class="ident">Vec</span>::<span class="ident">from</span>(<span class="string">&quot;CDEF&quot;</span>));
<span class="kw">let</span> <span class="ident">expected_len</span> <span class="op">=</span> <span class="ident">wbuf</span>.<span class="ident">len</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">f</span> <span class="op">=</span> <span class="ident">tempfile</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">aiocb</span> <span class="op">=</span> <span class="ident">AioCb</span>::<span class="ident">from_boxed_slice</span>( <span class="ident">f</span>.<span class="ident">as_raw_fd</span>(),
    <span class="number">2</span>,   <span class="comment">//offset</span>
    <span class="ident">wbuf</span>,
    <span class="number">0</span>,   <span class="comment">//priority</span>
    <span class="ident">SigevNotify</span>::<span class="ident">SigevNone</span>,
    <span class="ident">LioOpcode</span>::<span class="ident">LIO_NOP</span>);
<span class="ident">aiocb</span>.<span class="ident">write</span>().<span class="ident">unwrap</span>();
<span class="kw">while</span> (<span class="ident">aiocb</span>.<span class="ident">error</span>() <span class="op">=</span><span class="op">=</span> <span class="prelude-val">Err</span>(<span class="ident">Error</span>::<span class="ident">from</span>(<span class="ident">Errno</span>::<span class="ident">EINPROGRESS</span>))) {
    <span class="ident">thread</span>::<span class="ident">sleep</span>(<span class="ident">time</span>::<span class="ident">Duration</span>::<span class="ident">from_millis</span>(<span class="number">10</span>));
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">aiocb</span>.<span class="ident">aio_return</span>().<span class="ident">unwrap</span>() <span class="kw">as</span> <span class="ident">usize</span>, <span class="ident">expected_len</span>);</pre></div>
<p>Create an <code>AioCb</code> from a <code>Bytes</code> object</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">wbuf</span> <span class="op">=</span> <span class="ident">Box</span>::<span class="ident">new</span>(<span class="ident">Bytes</span>::<span class="ident">from</span>(<span class="kw-2">&amp;</span><span class="string">b&quot;CDEF&quot;</span>[..]));
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">f</span> <span class="op">=</span> <span class="ident">tempfile</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">aiocb</span> <span class="op">=</span> <span class="ident">AioCb</span>::<span class="ident">from_boxed_slice</span>( <span class="ident">f</span>.<span class="ident">as_raw_fd</span>(),
    <span class="number">2</span>,   <span class="comment">//offset</span>
    <span class="ident">wbuf</span>,
    <span class="number">0</span>,   <span class="comment">//priority</span>
    <span class="ident">SigevNotify</span>::<span class="ident">SigevNone</span>,
    <span class="ident">LioOpcode</span>::<span class="ident">LIO_NOP</span>);</pre></div>
<p>If a library needs to work with buffers that aren't <code>Box</code>ed, it can
create a <code>Box</code>ed container for use with this method.  Here's an example
using an un<code>Box</code>ed <code>Bytes</code> object.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">struct</span> <span class="ident">BytesContainer</span>(<span class="ident">Bytes</span>);
<span class="kw">impl</span> <span class="ident">Borrow</span><span class="op">&lt;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">BytesContainer</span> {
    <span class="kw">fn</span> <span class="ident">borrow</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="kw-2">&amp;</span>[<span class="ident">u8</span>] {
        <span class="self">self</span>.<span class="number">0</span>.<span class="ident">as_ref</span>()
    }
}
<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="ident">wbuf</span> <span class="op">=</span> <span class="ident">Bytes</span>::<span class="ident">from</span>(<span class="kw-2">&amp;</span><span class="string">b&quot;CDEF&quot;</span>[..]);
    <span class="kw">let</span> <span class="ident">boxed_wbuf</span> <span class="op">=</span> <span class="ident">Box</span>::<span class="ident">new</span>(<span class="ident">BytesContainer</span>(<span class="ident">wbuf</span>));
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">f</span> <span class="op">=</span> <span class="ident">tempfile</span>().<span class="ident">unwrap</span>();
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">aiocb</span> <span class="op">=</span> <span class="ident">AioCb</span>::<span class="ident">from_boxed_slice</span>( <span class="ident">f</span>.<span class="ident">as_raw_fd</span>(),
        <span class="number">2</span>,   <span class="comment">//offset</span>
        <span class="ident">boxed_wbuf</span>,
        <span class="number">0</span>,   <span class="comment">//priority</span>
        <span class="ident">SigevNotify</span>::<span class="ident">SigevNone</span>,
        <span class="ident">LioOpcode</span>::<span class="ident">LIO_NOP</span>);
}</pre></div>
</div><h4 id='method.from_boxed_mut_slice' class="method"><code>pub fn <a href='#method.from_boxed_mut_slice' class='fnname'>from_boxed_mut_slice</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;fd: <a class="type" href="https://doc.rust-lang.org/nightly/std/sys/unix/ext/io/type.RawFd.html" title="type std::sys::unix::ext::io::RawFd">RawFd</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;offs: <a class="type" href="../../../libc/unix/linux_like/linux/gnu/b64/type.off_t.html" title="type libc::unix::linux_like::linux::gnu::b64::off_t">off_t</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;buf: <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;dyn <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;, <br>&nbsp;&nbsp;&nbsp;&nbsp;prio: <a class="type" href="../../../libc/unix/type.c_int.html" title="type libc::unix::c_int">c_int</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;sigev_notify: <a class="enum" href="../../../nix/sys/signal/enum.SigevNotify.html" title="enum nix::sys::signal::SigevNotify">SigevNotify</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;opcode: <a class="enum" href="../../../nix/sys/aio/enum.LioOpcode.html" title="enum nix::sys::aio::LioOpcode">LioOpcode</a><br>) -&gt; <a class="struct" href="../../../nix/sys/aio/struct.AioCb.html" title="struct nix::sys::aio::AioCb">AioCb</a>&lt;'a&gt;</code><a class='srclink' href='../../../src/nix/sys/aio.rs.html#503-523' title='goto source code'>[src]</a></h4><div class='docblock'><p>The safest and most flexible way to create an <code>AioCb</code> for reading.</p>
<p>Like <a href="#method.from_boxed_slice"><code>from_boxed_slice</code></a>, but the slice is a mutable one.  More
flexible than <a href="#method.from_mut_slice"><code>from_mut_slice</code></a>, because a wide range of objects can be
used.</p>
<h1 id="examples-3" class="section-header"><a href="#examples-3">Examples</a></h1>
<p>Create an <code>AioCb</code> from a Vector and use it for reading</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">const</span> <span class="ident">INITIAL</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>] <span class="op">=</span> <span class="string">b&quot;abcdef123456&quot;</span>;
<span class="kw">const</span> <span class="ident">LEN</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="number">4</span>;
<span class="kw">let</span> <span class="ident">rbuf</span> <span class="op">=</span> <span class="ident">Box</span>::<span class="ident">new</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="number">0</span>; <span class="ident">LEN</span>]);
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">f</span> <span class="op">=</span> <span class="ident">tempfile</span>().<span class="ident">unwrap</span>();
<span class="ident">f</span>.<span class="ident">write_all</span>(<span class="ident">INITIAL</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">aiocb</span> <span class="op">=</span> <span class="ident">AioCb</span>::<span class="ident">from_boxed_mut_slice</span>( <span class="ident">f</span>.<span class="ident">as_raw_fd</span>(),
    <span class="number">2</span>,   <span class="comment">//offset</span>
    <span class="ident">rbuf</span>,
    <span class="number">0</span>,   <span class="comment">//priority</span>
    <span class="ident">SigevNotify</span>::<span class="ident">SigevNone</span>,
    <span class="ident">LioOpcode</span>::<span class="ident">LIO_NOP</span>);
<span class="ident">aiocb</span>.<span class="ident">read</span>().<span class="ident">unwrap</span>();
<span class="kw">while</span> (<span class="ident">aiocb</span>.<span class="ident">error</span>() <span class="op">=</span><span class="op">=</span> <span class="prelude-val">Err</span>(<span class="ident">Error</span>::<span class="ident">from</span>(<span class="ident">Errno</span>::<span class="ident">EINPROGRESS</span>))) {
    <span class="ident">thread</span>::<span class="ident">sleep</span>(<span class="ident">time</span>::<span class="ident">Duration</span>::<span class="ident">from_millis</span>(<span class="number">10</span>));
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">aiocb</span>.<span class="ident">aio_return</span>().<span class="ident">unwrap</span>() <span class="kw">as</span> <span class="ident">usize</span>, <span class="ident">LEN</span>);
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buffer</span> <span class="op">=</span> <span class="ident">aiocb</span>.<span class="ident">boxed_mut_slice</span>().<span class="ident">unwrap</span>();
<span class="kw">const</span> <span class="ident">EXPECT</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>] <span class="op">=</span> <span class="string">b&quot;cdef&quot;</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">buffer</span>.<span class="ident">borrow_mut</span>(), <span class="ident">EXPECT</span>);</pre></div>
</div><h4 id='method.from_mut_ptr' class="method"><code>pub unsafe fn <a href='#method.from_mut_ptr' class='fnname'>from_mut_ptr</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;fd: <a class="type" href="https://doc.rust-lang.org/nightly/std/sys/unix/ext/io/type.RawFd.html" title="type std::sys::unix::ext::io::RawFd">RawFd</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;offs: <a class="type" href="../../../libc/unix/linux_like/linux/gnu/b64/type.off_t.html" title="type libc::unix::linux_like::linux::gnu::b64::off_t">off_t</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;buf: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut </a><a class="enum" href="https://doc.rust-lang.org/nightly/core/ffi/enum.c_void.html" title="enum core::ffi::c_void">c_void</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;len: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;prio: <a class="type" href="../../../libc/unix/type.c_int.html" title="type libc::unix::c_int">c_int</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;sigev_notify: <a class="enum" href="../../../nix/sys/signal/enum.SigevNotify.html" title="enum nix::sys::signal::SigevNotify">SigevNotify</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;opcode: <a class="enum" href="../../../nix/sys/aio/enum.LioOpcode.html" title="enum nix::sys::aio::LioOpcode">LioOpcode</a><br>) -&gt; <a class="struct" href="../../../nix/sys/aio/struct.AioCb.html" title="struct nix::sys::aio::AioCb">AioCb</a>&lt;'a&gt;</code><a class='srclink' href='../../../src/nix/sys/aio.rs.html#552-568' title='goto source code'>[src]</a></h4><div class='docblock'><p>Constructs a new <code>AioCb</code> from a mutable raw pointer</p>
<p>Unlike <code>from_mut_slice</code>, this method returns a structure suitable for
placement on the heap.  It may be used for both reads and writes.  Due
to its unsafety, this method is not recommended.  It is most useful when
heap allocation is required but for some reason the data cannot be
wrapped in a <code>struct</code> that implements <code>BorrowMut&lt;[u8]&gt;</code></p>
<h1 id="parameters-3" class="section-header"><a href="#parameters-3">Parameters</a></h1>
<ul>
<li><code>fd</code>:           File descriptor.  Required for all aio functions.</li>
<li><code>offs</code>:         File offset</li>
<li><code>buf</code>:          Pointer to the memory buffer</li>
<li><code>len</code>:          Length of the buffer pointed to by <code>buf</code></li>
<li><code>prio</code>:         If POSIX Prioritized IO is supported, then the
operation will be prioritized at the process's
priority level minus <code>prio</code></li>
<li><code>sigev_notify</code>: Determines how you will be notified of event
completion.</li>
<li><code>opcode</code>:       This field is only used for <code>lio_listio</code>.  It
determines which operation to use for this individual
aiocb</li>
</ul>
<h1 id="safety" class="section-header"><a href="#safety">Safety</a></h1>
<p>The caller must ensure that the storage pointed to by <code>buf</code> outlives the
<code>AioCb</code>.  The lifetime checker can't help here.</p>
</div><h4 id='method.from_ptr' class="method"><code>pub unsafe fn <a href='#method.from_ptr' class='fnname'>from_ptr</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;fd: <a class="type" href="https://doc.rust-lang.org/nightly/std/sys/unix/ext/io/type.RawFd.html" title="type std::sys::unix::ext::io::RawFd">RawFd</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;offs: <a class="type" href="../../../libc/unix/linux_like/linux/gnu/b64/type.off_t.html" title="type libc::unix::linux_like::linux::gnu::b64::off_t">off_t</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;buf: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*const </a><a class="enum" href="https://doc.rust-lang.org/nightly/core/ffi/enum.c_void.html" title="enum core::ffi::c_void">c_void</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;len: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;prio: <a class="type" href="../../../libc/unix/type.c_int.html" title="type libc::unix::c_int">c_int</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;sigev_notify: <a class="enum" href="../../../nix/sys/signal/enum.SigevNotify.html" title="enum nix::sys::signal::SigevNotify">SigevNotify</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;opcode: <a class="enum" href="../../../nix/sys/aio/enum.LioOpcode.html" title="enum nix::sys::aio::LioOpcode">LioOpcode</a><br>) -&gt; <a class="struct" href="../../../nix/sys/aio/struct.AioCb.html" title="struct nix::sys::aio::AioCb">AioCb</a>&lt;'a&gt;</code><a class='srclink' href='../../../src/nix/sys/aio.rs.html#597-615' title='goto source code'>[src]</a></h4><div class='docblock'><p>Constructs a new <code>AioCb</code> from a raw pointer.</p>
<p>Unlike <code>from_slice</code>, this method returns a structure suitable for
placement on the heap.  Due to its unsafety, this method is not
recommended.  It is most useful when heap allocation is required but for
some reason the data cannot be wrapped in a <code>struct</code> that implements
<code>Borrow&lt;[u8]&gt;</code></p>
<h1 id="parameters-4" class="section-header"><a href="#parameters-4">Parameters</a></h1>
<ul>
<li><code>fd</code>:           File descriptor.  Required for all aio functions.</li>
<li><code>offs</code>:         File offset</li>
<li><code>buf</code>:          Pointer to the memory buffer</li>
<li><code>len</code>:          Length of the buffer pointed to by <code>buf</code></li>
<li><code>prio</code>:         If POSIX Prioritized IO is supported, then the
operation will be prioritized at the process's
priority level minus <code>prio</code></li>
<li><code>sigev_notify</code>: Determines how you will be notified of event
completion.</li>
<li><code>opcode</code>:       This field is only used for <code>lio_listio</code>.  It
determines which operation to use for this individual
aiocb</li>
</ul>
<h1 id="safety-1" class="section-header"><a href="#safety-1">Safety</a></h1>
<p>The caller must ensure that the storage pointed to by <code>buf</code> outlives the
<code>AioCb</code>.  The lifetime checker can't help here.</p>
</div><h4 id='method.from_slice' class="method"><code>pub fn <a href='#method.from_slice' class='fnname'>from_slice</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;fd: <a class="type" href="https://doc.rust-lang.org/nightly/std/sys/unix/ext/io/type.RawFd.html" title="type std::sys::unix::ext::io::RawFd">RawFd</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;offs: <a class="type" href="../../../libc/unix/linux_like/linux/gnu/b64/type.off_t.html" title="type libc::unix::linux_like::linux::gnu::b64::off_t">off_t</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;buf: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'a [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;prio: <a class="type" href="../../../libc/unix/type.c_int.html" title="type libc::unix::c_int">c_int</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;sigev_notify: <a class="enum" href="../../../nix/sys/signal/enum.SigevNotify.html" title="enum nix::sys::signal::SigevNotify">SigevNotify</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;opcode: <a class="enum" href="../../../nix/sys/aio/enum.LioOpcode.html" title="enum nix::sys::aio::LioOpcode">LioOpcode</a><br>) -&gt; <a class="struct" href="../../../nix/sys/aio/struct.AioCb.html" title="struct nix::sys::aio::AioCb">AioCb</a>&lt;'_&gt;</code><a class='srclink' href='../../../src/nix/sys/aio.rs.html#658-677' title='goto source code'>[src]</a></h4><div class='docblock'><p>Like <code>from_mut_slice</code>, but works on constant slices rather than
mutable slices.</p>
<p>An <code>AioCb</code> created this way cannot be used with <code>read</code>, and its
<code>LioOpcode</code> cannot be set to <code>LIO_READ</code>.  This method is useful when
writing a const buffer with <code>AioCb::write</code>, since <code>from_mut_slice</code> can't
work with const buffers.</p>
<h1 id="examples-4" class="section-header"><a href="#examples-4">Examples</a></h1>
<p>Construct an <code>AioCb</code> from a slice and use it for writing.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">const</span> <span class="ident">WBUF</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>] <span class="op">=</span> <span class="string">b&quot;abcdef123456&quot;</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">f</span> <span class="op">=</span> <span class="ident">tempfile</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">aiocb</span> <span class="op">=</span> <span class="ident">AioCb</span>::<span class="ident">from_slice</span>( <span class="ident">f</span>.<span class="ident">as_raw_fd</span>(),
    <span class="number">2</span>,   <span class="comment">//offset</span>
    <span class="ident">WBUF</span>,
    <span class="number">0</span>,   <span class="comment">//priority</span>
    <span class="ident">SigevNotify</span>::<span class="ident">SigevNone</span>,
    <span class="ident">LioOpcode</span>::<span class="ident">LIO_NOP</span>);
<span class="ident">aiocb</span>.<span class="ident">write</span>().<span class="ident">unwrap</span>();
<span class="kw">while</span> (<span class="ident">aiocb</span>.<span class="ident">error</span>() <span class="op">=</span><span class="op">=</span> <span class="prelude-val">Err</span>(<span class="ident">Error</span>::<span class="ident">from</span>(<span class="ident">Errno</span>::<span class="ident">EINPROGRESS</span>))) {
    <span class="ident">thread</span>::<span class="ident">sleep</span>(<span class="ident">time</span>::<span class="ident">Duration</span>::<span class="ident">from_millis</span>(<span class="number">10</span>));
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">aiocb</span>.<span class="ident">aio_return</span>().<span class="ident">unwrap</span>() <span class="kw">as</span> <span class="ident">usize</span>, <span class="ident">WBUF</span>.<span class="ident">len</span>());</pre></div>
</div><h4 id='method.set_sigev_notify' class="method"><code>pub fn <a href='#method.set_sigev_notify' class='fnname'>set_sigev_notify</a>(&amp;mut self, sigev_notify: <a class="enum" href="../../../nix/sys/signal/enum.SigevNotify.html" title="enum nix::sys::signal::SigevNotify">SigevNotify</a>)</code><a class='srclink' href='../../../src/nix/sys/aio.rs.html#693-695' title='goto source code'>[src]</a></h4><div class='docblock'><p>Update the notification settings for an existing <code>aiocb</code></p>
</div><h4 id='method.cancel' class="method"><code>pub fn <a href='#method.cancel' class='fnname'>cancel</a>(&amp;mut self) -&gt; <a class="type" href="../../../nix/type.Result.html" title="type nix::Result">Result</a>&lt;<a class="enum" href="../../../nix/sys/aio/enum.AioCancelStat.html" title="enum nix::sys::aio::AioCancelStat">AioCancelStat</a>&gt;</code><a class='srclink' href='../../../src/nix/sys/aio.rs.html#744-752' title='goto source code'>[src]</a></h4><div class='docblock'><p>Cancels an outstanding AIO request.</p>
<p>The operating system is not required to implement cancellation for all
file and device types.  Even if it does, there is no guarantee that the
operation has not already completed.  So the caller must check the
result and handle operations that were not canceled or that have already
completed.</p>
<h1 id="examples-5" class="section-header"><a href="#examples-5">Examples</a></h1>
<p>Cancel an outstanding aio operation.  Note that we must still call
<code>aio_return</code> to free resources, even though we don't care about the
result.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">wbuf</span> <span class="op">=</span> <span class="string">b&quot;CDEF&quot;</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">f</span> <span class="op">=</span> <span class="ident">tempfile</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">aiocb</span> <span class="op">=</span> <span class="ident">AioCb</span>::<span class="ident">from_slice</span>( <span class="ident">f</span>.<span class="ident">as_raw_fd</span>(),
    <span class="number">2</span>,   <span class="comment">//offset</span>
    <span class="kw-2">&amp;</span><span class="ident">wbuf</span>[..],
    <span class="number">0</span>,   <span class="comment">//priority</span>
    <span class="ident">SigevNotify</span>::<span class="ident">SigevNone</span>,
    <span class="ident">LioOpcode</span>::<span class="ident">LIO_NOP</span>);
<span class="ident">aiocb</span>.<span class="ident">write</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">cs</span> <span class="op">=</span> <span class="ident">aiocb</span>.<span class="ident">cancel</span>().<span class="ident">unwrap</span>();
<span class="kw">if</span> <span class="ident">cs</span> <span class="op">=</span><span class="op">=</span> <span class="ident">AioCancelStat</span>::<span class="ident">AioNotCanceled</span> {
    <span class="kw">while</span> (<span class="ident">aiocb</span>.<span class="ident">error</span>() <span class="op">=</span><span class="op">=</span> <span class="prelude-val">Err</span>(<span class="ident">Error</span>::<span class="ident">from</span>(<span class="ident">Errno</span>::<span class="ident">EINPROGRESS</span>))) {
        <span class="ident">thread</span>::<span class="ident">sleep</span>(<span class="ident">time</span>::<span class="ident">Duration</span>::<span class="ident">from_millis</span>(<span class="number">10</span>));
    }
}
<span class="comment">// Must call `aio_return`, but ignore the result</span>
<span class="kw">let</span> <span class="kw">_</span> <span class="op">=</span> <span class="ident">aiocb</span>.<span class="ident">aio_return</span>();</pre></div>
<h1 id="references" class="section-header"><a href="#references">References</a></h1>
<p><a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/aio_cancel.html">aio_cancel</a></p>
</div><h4 id='method.error' class="method"><code>pub fn <a href='#method.error' class='fnname'>error</a>(&amp;mut self) -&gt; <a class="type" href="../../../nix/type.Result.html" title="type nix::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</code><a class='srclink' href='../../../src/nix/sys/aio.rs.html#792-799' title='goto source code'>[src]</a></h4><div class='docblock'><p>Retrieve error status of an asynchronous operation.</p>
<p>If the request has not yet completed, returns <code>EINPROGRESS</code>.  Otherwise,
returns <code>Ok</code> or any other error.</p>
<h1 id="examples-6" class="section-header"><a href="#examples-6">Examples</a></h1>
<p>Issue an aio operation and use <code>error</code> to poll for completion.  Polling
is an alternative to <code>aio_suspend</code>, used by most of the other examples.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">const</span> <span class="ident">WBUF</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>] <span class="op">=</span> <span class="string">b&quot;abcdef123456&quot;</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">f</span> <span class="op">=</span> <span class="ident">tempfile</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">aiocb</span> <span class="op">=</span> <span class="ident">AioCb</span>::<span class="ident">from_slice</span>( <span class="ident">f</span>.<span class="ident">as_raw_fd</span>(),
    <span class="number">2</span>,   <span class="comment">//offset</span>
    <span class="ident">WBUF</span>,
    <span class="number">0</span>,   <span class="comment">//priority</span>
    <span class="ident">SigevNotify</span>::<span class="ident">SigevNone</span>,
    <span class="ident">LioOpcode</span>::<span class="ident">LIO_NOP</span>);
<span class="ident">aiocb</span>.<span class="ident">write</span>().<span class="ident">unwrap</span>();
<span class="kw">while</span> (<span class="ident">aiocb</span>.<span class="ident">error</span>() <span class="op">=</span><span class="op">=</span> <span class="prelude-val">Err</span>(<span class="ident">Error</span>::<span class="ident">from</span>(<span class="ident">Errno</span>::<span class="ident">EINPROGRESS</span>))) {
    <span class="ident">thread</span>::<span class="ident">sleep</span>(<span class="ident">time</span>::<span class="ident">Duration</span>::<span class="ident">from_millis</span>(<span class="number">10</span>));
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">aiocb</span>.<span class="ident">aio_return</span>().<span class="ident">unwrap</span>() <span class="kw">as</span> <span class="ident">usize</span>, <span class="ident">WBUF</span>.<span class="ident">len</span>());</pre></div>
<h1 id="references-1" class="section-header"><a href="#references-1">References</a></h1>
<p><a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/aio_error.html">aio_error</a></p>
</div><h4 id='method.fsync' class="method"><code>pub fn <a href='#method.fsync' class='fnname'>fsync</a>(&amp;mut self, mode: <a class="enum" href="../../../nix/sys/aio/enum.AioFsyncMode.html" title="enum nix::sys::aio::AioFsyncMode">AioFsyncMode</a>) -&gt; <a class="type" href="../../../nix/type.Result.html" title="type nix::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</code><a class='srclink' href='../../../src/nix/sys/aio.rs.html#806-813' title='goto source code'>[src]</a></h4><div class='docblock'><p>An asynchronous version of <code>fsync(2)</code>.</p>
<h1 id="references-2" class="section-header"><a href="#references-2">References</a></h1>
<p><a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/aio_fsync.html">aio_fsync</a></p>
</div><h4 id='method.lio_opcode' class="method"><code>pub fn <a href='#method.lio_opcode' class='fnname'>lio_opcode</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="../../../nix/sys/aio/enum.LioOpcode.html" title="enum nix::sys::aio::LioOpcode">LioOpcode</a>&gt;</code><a class='srclink' href='../../../src/nix/sys/aio.rs.html#819-826' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns the <code>aiocb</code>'s <code>LioOpcode</code> field</p>
<p>If the value cannot be represented as an <code>LioOpcode</code>, returns <code>None</code>
instead.</p>
</div><h4 id='method.nbytes' class="method"><code>pub fn <a href='#method.nbytes' class='fnname'>nbytes</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code><a class='srclink' href='../../../src/nix/sys/aio.rs.html#833-835' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns the requested length of the aio operation in bytes</p>
<p>This method returns the <em>requested</em> length of the operation.  To get the
number of bytes actually read or written by a completed operation, use
<code>aio_return</code> instead.</p>
</div><h4 id='method.offset' class="method"><code>pub fn <a href='#method.offset' class='fnname'>offset</a>(&amp;self) -&gt; <a class="type" href="../../../libc/unix/linux_like/linux/gnu/b64/type.off_t.html" title="type libc::unix::linux_like::linux::gnu::b64::off_t">off_t</a></code><a class='srclink' href='../../../src/nix/sys/aio.rs.html#838-840' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns the file offset stored in the <code>AioCb</code></p>
</div><h4 id='method.priority' class="method"><code>pub fn <a href='#method.priority' class='fnname'>priority</a>(&amp;self) -&gt; <a class="type" href="../../../libc/unix/type.c_int.html" title="type libc::unix::c_int">c_int</a></code><a class='srclink' href='../../../src/nix/sys/aio.rs.html#843-845' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns the priority of the <code>AioCb</code></p>
</div><h4 id='method.read' class="method"><code>pub fn <a href='#method.read' class='fnname'>read</a>(&amp;mut self) -&gt; <a class="type" href="../../../nix/type.Result.html" title="type nix::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</code><a class='srclink' href='../../../src/nix/sys/aio.rs.html#852-860' title='goto source code'>[src]</a></h4><div class='docblock'><p>Asynchronously reads from a file descriptor into a buffer</p>
<h1 id="references-3" class="section-header"><a href="#references-3">References</a></h1>
<p><a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/aio_read.html">aio_read</a></p>
</div><h4 id='method.sigevent' class="method"><code>pub fn <a href='#method.sigevent' class='fnname'>sigevent</a>(&amp;self) -&gt; <a class="struct" href="../../../nix/sys/signal/struct.SigEvent.html" title="struct nix::sys::signal::SigEvent">SigEvent</a></code><a class='srclink' href='../../../src/nix/sys/aio.rs.html#863-865' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns the <code>SigEvent</code> stored in the <code>AioCb</code></p>
</div><h4 id='method.aio_return' class="method"><code>pub fn <a href='#method.aio_return' class='fnname'>aio_return</a>(&amp;mut self) -&gt; <a class="type" href="../../../nix/type.Result.html" title="type nix::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.isize.html">isize</a>&gt;</code><a class='srclink' href='../../../src/nix/sys/aio.rs.html#877-881' title='goto source code'>[src]</a></h4><div class='docblock'><p>Retrieve return status of an asynchronous operation.</p>
<p>Should only be called once for each <code>AioCb</code>, after <code>AioCb::error</code>
indicates that it has completed.  The result is the same as for the
synchronous <code>read(2)</code>, <code>write(2)</code>, of <code>fsync(2)</code> functions.</p>
<h1 id="references-4" class="section-header"><a href="#references-4">References</a></h1>
<p><a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/aio_return.html">aio_return</a></p>
</div><h4 id='method.write' class="method"><code>pub fn <a href='#method.write' class='fnname'>write</a>(&amp;mut self) -&gt; <a class="type" href="../../../nix/type.Result.html" title="type nix::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</code><a class='srclink' href='../../../src/nix/sys/aio.rs.html#888-895' title='goto source code'>[src]</a></h4><div class='docblock'><p>Asynchronously writes from a buffer to a file descriptor</p>
<h1 id="references-5" class="section-header"><a href="#references-5">References</a></h1>
<p><a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/aio_write.html">aio_write</a></p>
</div></div><h2 id='trait-implementations' class='small-section-header'>Trait Implementations<a href='#trait-implementations' class='anchor'></a></h2><div id='trait-implementations-list'><h3 id='impl-Debug' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="../../../nix/sys/aio/struct.AioCb.html" title="struct nix::sys::aio::AioCb">AioCb</a>&lt;'a&gt;</code><a href='#impl-Debug' class='anchor'></a><a class='srclink' href='../../../src/nix/sys/aio.rs.html#992-1000' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.fmt' class="method hidden"><code>fn <a href='https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt' class='fnname'>fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code><a class='srclink' href='../../../src/nix/sys/aio.rs.html#993-999' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></div><h3 id='impl-Drop' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/drop/trait.Drop.html" title="trait core::ops::drop::Drop">Drop</a> for <a class="struct" href="../../../nix/sys/aio/struct.AioCb.html" title="struct nix::sys::aio::AioCb">AioCb</a>&lt;'a&gt;</code><a href='#impl-Drop' class='anchor'></a><a class='srclink' href='../../../src/nix/sys/aio.rs.html#1002-1009' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.drop' class="method"><code>fn <a href='https://doc.rust-lang.org/nightly/core/ops/drop/trait.Drop.html#tymethod.drop' class='fnname'>drop</a>(&amp;mut self)</code><a class='srclink' href='../../../src/nix/sys/aio.rs.html#1005-1008' title='goto source code'>[src]</a></h4><div class='docblock'><p>If the <code>AioCb</code> has no remaining state in the kernel, just drop it.
Otherwise, dropping constitutes a resource leak, which is an error</p>
</div></div></div><h2 id='synthetic-implementations' class='small-section-header'>Auto Trait Implementations<a href='#synthetic-implementations' class='anchor'></a></h2><div id='synthetic-implementations-list'><h3 id='impl-RefUnwindSafe' class='impl'><code class='in-band'>impl&lt;'a&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="../../../nix/sys/aio/struct.AioCb.html" title="struct nix::sys::aio::AioCb">AioCb</a>&lt;'a&gt;</code><a href='#impl-RefUnwindSafe' class='anchor'></a></h3><div class='impl-items'></div><h3 id='impl-Send' class='impl'><code class='in-band'>impl&lt;'a&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="../../../nix/sys/aio/struct.AioCb.html" title="struct nix::sys::aio::AioCb">AioCb</a>&lt;'a&gt;</code><a href='#impl-Send' class='anchor'></a></h3><div class='impl-items'></div><h3 id='impl-Sync' class='impl'><code class='in-band'>impl&lt;'a&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="../../../nix/sys/aio/struct.AioCb.html" title="struct nix::sys::aio::AioCb">AioCb</a>&lt;'a&gt;</code><a href='#impl-Sync' class='anchor'></a></h3><div class='impl-items'></div><h3 id='impl-Unpin' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="../../../nix/sys/aio/struct.AioCb.html" title="struct nix::sys::aio::AioCb">AioCb</a>&lt;'a&gt;</code><a href='#impl-Unpin' class='anchor'></a></h3><div class='impl-items'></div><h3 id='impl-UnwindSafe' class='impl'><code class='in-band'>impl&lt;'a&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a> for <a class="struct" href="../../../nix/sys/aio/struct.AioCb.html" title="struct nix::sys::aio::AioCb">AioCb</a>&lt;'a&gt;</code><a href='#impl-UnwindSafe' class='anchor'></a></h3><div class='impl-items'></div></div><h2 id='blanket-implementations' class='small-section-header'>Blanket Implementations<a href='#blanket-implementations' class='anchor'></a></h2><div id='blanket-implementations-list'><h3 id='impl-Any' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Any' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/any.rs.html#108-112' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.type_id' class="method hidden"><code>fn <a href='https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id' class='fnname'>type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/any.rs.html#109-111' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></div><h3 id='impl-Borrow%3CT%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Borrow%3CT%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#210-214' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.borrow' class="method hidden"><code>fn <a href='https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow' class='fnname'>borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#211-213' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></div><h3 id='impl-BorrowMut%3CT%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-BorrowMut%3CT%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#217-221' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.borrow_mut' class="method hidden"><code>fn <a href='https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut' class='fnname'>borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#218-220' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></div><h3 id='impl-From%3CT%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</code><a href='#impl-From%3CT%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#551-555' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.from' class="method hidden"><code>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from' class='fnname'>from</a>(t: T) -&gt; T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#552-554' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-Into%3CU%3E' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-Into%3CU%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#540-547' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.into' class="method hidden"><code>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into' class='fnname'>into</a>(self) -&gt; U</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#544-546' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-TryFrom%3CU%3E' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-TryFrom%3CU%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#588-597' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Error' class="type"><code>type <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error' class="type">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id='method.try_from' class="method hidden"><code>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from' class='fnname'>try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#594-596' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-TryInto%3CU%3E' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-TryInto%3CU%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#574-583' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Error-1' class="type"><code>type <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error' class="type">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id='method.try_into' class="method hidden"><code>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into' class='fnname'>try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#580-582' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div></div></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../../../";window.currentCrate = "nix";</script><script src="../../../main.js"></script><script defer src="../../../search-index.js"></script></body></html>